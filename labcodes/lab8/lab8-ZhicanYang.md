# Lab8 Report#
---
## [练习0] 填写已有实验 ##

使用`meld`工具辅助人工检查完成。

## [练习1] 完成读文件操作的实现 ##

#### 1. 给出设计实现“Unix的Pipe机制”的概要设计方案 ####

给每个管道分配一定空间作为缓冲区，如一个页面。设计一个循环队列缓冲数据：

* 循环队列有头尾指针，当两指针重合时表示队列为空。
* 当有数据加入循环队列（缓冲）时，将其插入队尾，并使尾指针右移。若尾指针移出给该管道所分配的空间，则将其重新置为分配的空间的最左端。
* 当有数据弹出循环队列（读取）时，弹出头部元素，并使头指针右移。同理，若头指针移出给该管道所分配的空间，则将其重新置为分配的空间的最左端。

使用循环队列作为缓冲区，只要同一时刻在缓冲区的数据不超过给该管道分配的空间大小，就可以一直正常运行下去。

设计好缓冲区后，还需要解决进程访问管道的同步互斥问题，可以使用任何一种实现。

比如采用信号量实现：

* 从管道读取时，若信号量大于0，则读取；若信号量小等于0（头指针等于尾指针），则等待该信号量。
* 缓冲至管道时，更新信号量后自然会唤醒在等待的进程（若存在）。
* 同一时刻只有一个进程可以对信号量和缓冲区做操作，这一点采用在介绍信号量时提及的临界区相同的实现即可。

## [练习2] 完成基于文件系统的执行程序机制的实现 ##

#### 1. 给出设计实现基于”Unix的硬链接和软链接机制“的概要设计方案 ####

硬链接：多个文件的`inode`指向硬盘上同一块数据（文件）。

在具体实现中，设计一个接口，把新文件的`inode`指向旧文件，引用计数加一。在进行读写操作时，使用任意一个`inode`都能操纵该文件，做好相应的同步互斥处理即可；进行删除操作时，将引用计数减一，只有当计数为零时，才直接删除这个文件。

软链接：新的`inode`指向一个新文件，该文件存储被链接的文件的地址。

在具体实现中，设计一个接口，正常初始化新文件，设置`disk_inode`类型为`SFS_TYPE_LINK`，存储内容为旧文件的地址。执行读写操作时，若类型为`SFS_TYPE_LINK`，则要依据路径获取真正文件后读写；删除操作时，若没有采用多级软链接的话，直接删除即可；若软链接可以嵌套软链接的话，则同样要维护引用计数，当引用计数为零时才可完全删去避免链接链的断裂。


## 我的实现与参考答案的区别 ##

在此前的Lab1和Lab4初始化中，已经使用`memset`清零了各项，处理了相对应的边界情况，所以在本Lab中不需要做改动。

我使用的是Lab6中是实现的`Stride Scheduling`调度算法，而答案使用的仍是`Round Robin`调度算法。这样在触发时间中断时，需要调用`Stride Scheduling`算法中的`sched_proc_tick()`。

在`sfs_io_nolock`的实现中，我采用的是基于指针的处理，逻辑简单，边界情况少，因为不需维护当前块编号和剩余块数等实际上是互为冗余的变量，实现的代码比答案的实现精简得多（约减少一半）。


## 重要知识点 ##

1. 从上至下的文件系统
	1. FS syscall接口
	2. FS syscall实现
	3. VFS
	4. SimpleFS
	5. I/O接口
	6. 硬件
2. SimpleFS中硬盘的组织方式：
	1. superblock
	2. root-dir inode
	3. freemap
	4. Inode/File Data/Dir Data blocks
3. 打开/读写文件的执行流程

未在原理中提到的：

1. 软链接和硬链接的区别和实现，详见上文。 
2. 各种硬件如何做到相同的接口（屏蔽不同硬件），可能较为繁琐、意义不大所以未在原理与实验中涉及。